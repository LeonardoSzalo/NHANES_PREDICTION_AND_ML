import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import roc_curve, auc, accuracy_score
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, label_binarize
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
import xgboost as xgb
import base64
from io import BytesIO

def run():
    st.title("Página 3 - Script 3")
    st.write("Conteúdo do Script 3")

    def preprocess_data(df, alvo):
        categorical_vars_dict = {
            'DIABETES': [
                'ALCOHOL_FREQUENCY', 'VIGOROUS_ACTIVITY', 'MODERATE_ACTIVITY', 'SMOKE', 
                'KIDNEY_DISEASE', 'DIALYSES', 'GENDER', 'RACE', 'EDUCATION', 
                'MARITAL_STATUS', 'HIGH_PRESSURE', 'HIGH_CHOLESTEROL', 
                'ASTHMA', 'BLOOD_TRANSFUSION', 'ARTHRITIS', 'CONGESTIVE_HEART_FAILURE', 
                'CORONARY_DISEASE', 'HEART_ATTACK', 'STROKE', 'THYROID_PROBLEMA', 
                'COPD', 'LIVER_DISEASE', 'ABDOMINAL_PAIN', 'GALLSTONES', 'CANCER', 
                'HEALTH_INSURANCE', 'SNORE', 'SNORT', 'TROUBLE_SLEEPING', 'OVERLY_SLEEPY'
            ],
            'HEART_ATTACK': [
                'ALCOHOL_FREQUENCY', 'VIGOROUS_ACTIVITY', 'MODERATE_ACTIVITY', 'SMOKE', 
                'KIDNEY_DISEASE', 'DIALYSES', 'GENDER', 'RACE', 'EDUCATION', 
                'MARITAL_STATUS', 'HIGH_PRESSURE', 'HIGH_CHOLESTEROL', 
                'ASTHMA', 'BLOOD_TRANSFUSION', 'ARTHRITIS', 'CONGESTIVE_HEART_FAILURE', 
                'CORONARY_DISEASE', 'DIABETES', 'STROKE', 'THYROID_PROBLEMA', 
                'COPD', 'LIVER_DISEASE', 'ABDOMINAL_PAIN', 'GALLSTONES', 'CANCER', 
                'HEALTH_INSURANCE', 'SNORE', 'SNORT', 'TROUBLE_SLEEPING', 'OVERLY_SLEEPY'
            ],
            'STROKE': [
                'ALCOHOL_FREQUENCY', 'VIGOROUS_ACTIVITY', 'MODERATE_ACTIVITY', 'SMOKE', 
                'KIDNEY_DISEASE', 'DIALYSES', 'GENDER', 'RACE', 'EDUCATION', 
                'MARITAL_STATUS', 'HIGH_PRESSURE', 'HIGH_CHOLESTEROL', 
                'ASTHMA', 'BLOOD_TRANSFUSION', 'ARTHRITIS', 'CONGESTIVE_HEART_FAILURE', 
                'CORONARY_DISEASE', 'DIABETES', 'HEART_ATTACK', 'THYROID_PROBLEMA', 
                'COPD', 'LIVER_DISEASE', 'ABDOMINAL_PAIN', 'GALLSTONES', 'CANCER', 
                'HEALTH_INSURANCE', 'SNORE', 'SNORT', 'TROUBLE_SLEEPING', 'OVERLY_SLEEPY'
            ]
        }

        categorical_vars = categorical_vars_dict.get(alvo, [])

        y = df[alvo]
        X = df.drop(columns=[alvo])
        
        X_encoded = pd.get_dummies(X, columns=categorical_vars, drop_first=True)
        
        numerical_vars = X_encoded.select_dtypes(include=['float64', 'int64']).columns
        scaler = StandardScaler()
        X_encoded[numerical_vars] = scaler.fit_transform(X_encoded[numerical_vars])
        
        return X_encoded, y

    def plot_roc_curve(model, X_test, y_test, model_name, num_classes=None):
        fig, ax = plt.subplots(figsize=(8, 6))
        if num_classes and num_classes > 2:
            from sklearn.preprocessing import label_binarize
            
            y_test_bin = label_binarize(y_test, classes=model.classes_)
            y_prob = model.predict_proba(X_test)
            
            fpr = {}
            tpr = {}
            roc_auc = {}
            for i in range(y_test_bin.shape[1]):
                fpr[i], tpr[i], _ = roc_curve(y_test_bin[:, i], y_prob[:, i])
                roc_auc[i] = auc(fpr[i], tpr[i])
            
            for i in range(y_test_bin.shape[1]):
                ax.plot(fpr[i], tpr[i], label=f'Class {model.classes_[i]} (AUC = {roc_auc[i]:.4f})')
            ax.plot([0, 1], [0, 1], color='#e85d04', linestyle='--')
            ax.fill_between(fpr[i], tpr[i], alpha=0.2, color='#023047')
            ax.set_xlim([0.0, 1.0])
            ax.set_ylim([0.0, 1.05])
            ax.set_xlabel('False Positive Rate (FPR)', fontsize=12)
            ax.set_ylabel('True Positive Rate (TPR)', fontsize=12)
            ax.set_title(f'ROC AUC - {model_name} (Multiclass)', fontsize=14)
            ax.legend(loc='lower right')
            ax.grid(False)
        else:
            if hasattr(model, "predict_proba"):
                y_prob = model.predict_proba(X_test)[:, 1]
            elif hasattr(model, "decision_function"):
                y_prob = model.decision_function(X_test)
                y_prob = (y_prob - y_prob.min()) / (y_prob.max() - y_prob.min())
            else:
                raise ValueError(f"O modelo {model_name} não suporta previsão de probabilidade.")
            
            fpr, tpr, _ = roc_curve(y_test, y_prob)
            roc_auc = auc(fpr, tpr)
            
            ax.plot(fpr, tpr, label=f'{model_name} (AUC = {roc_auc:.4f})')
            ax.plot([0, 1], [0, 1], color='#e85d04', linestyle='--')
            ax.fill_between(fpr, tpr, alpha=0.2, color='#023047')
            ax.set_xlim([0.0, 1.0])
            ax.set_ylim([0.0, 1.05])
            ax.set_xlabel('False Positive Rate (FPR)', fontsize=12)
            ax.set_ylabel('True Positive Rate (TPR)', fontsize=12)
            ax.set_title(f'ROC AUC - {model_name}', fontsize=14)
            ax.legend(loc='lower right')
            ax.grid(False)

        # Salvar imagem em um buffer
        buffer = BytesIO()
        plt.savefig(buffer, format='png')
        buffer.seek(0)
        img_base64 = base64.b64encode(buffer.getvalue()).decode()
        st.markdown(f'<div style="text-align: center;"><img src="data:image/png;base64,{img_base64}" style="max-width: 100%; height: auto;" /></div>', unsafe_allow_html=True)
        st.write(f"Gráfico da curva ROC para o modelo {model_name}")
        plt.close(fig)

    def plot_top_features(coef_df, top_n=5):
        color_palette = ['#023047', '#e85d04', '#0077b6', '#0096c7', '#ff9c33']
        top_features = coef_df.sort_values(by='Coefficient', ascending=False).head(top_n)
        fig, ax = plt.subplots(figsize=(12, 8))
        sns.barplot(x='Coefficient', y='Feature', data=top_features, palette=color_palette, ax=ax)
        ax.set_title('Top 5 Variáveis - Regressão Logística', fontsize=14)
        ax.set_xlabel('Coeficiente', fontsize=12)
        ax.set_ylabel('Variável', fontsize=12)
        ax.grid(False)
        plt.yticks(rotation=45)

        # Salvar imagem em um buffer
        buffer = BytesIO()
        plt.savefig(buffer, format='png')
        buffer.seek(0)
        img_base64 = base64.b64encode(buffer.getvalue()).decode()
        st.markdown(f'<div style="text-align: center;"><img src="data:image/png;base64,{img_base64}" style="max-width: 100%; height: auto;" /></div>', unsafe_allow_html=True)
        st.write("Gráfico das top 5 variáveis com maior coeficiente")
        plt.close(fig)

    def train_and_evaluate_model(model_name, X_train, X_test, y_train, y_test):
        models = {
            'Logistic Regression': LogisticRegression(random_state=42, max_iter=1000, C=0.1, penalty='l1', solver='liblinear'),
            'Decision Tree': DecisionTreeClassifier(random_state=42),
            'Random Forest': RandomForestClassifier(random_state=42),
            'SVM': SVC(random_state=42, probability=True),
            'XGBoost': xgb.XGBClassifier(random_state=42, use_label_encoder=False, eval_metric='logloss')
        }
        
        model = models[model_name]
        model.fit(X_train, y_train)
        y_pred = model.predict(X_test)
        acc = accuracy_score(y_test, y_pred)
        
        st.write(f"Acurácia do modelo {model_name}: {acc:.4f}")
        
        if model_name == 'Logistic Regression':
            coef_df = pd.DataFrame({
                'Feature': X_train.columns,
                'Coefficient': model.coef_.flatten()
            }).sort_values(by='Coefficient', ascending=False)
            plot_top_features(coef_df)
        
        st.write(f"Exibindo a curva ROC para o modelo {model_name}")
        
        if model_name == 'Logistic Regression':
            num_classes = len(set(y_train))
            plot_roc_curve(model, X_test, y_test, model_name, num_classes=num_classes)
        else:
            plot_roc_curve(model, X_test, y_test, model_name)

    df = pd.read_excel(r"C:\Users\leosz\Desktop\Streamlit_Nhanes\dados_demograficos_streamlit.xlsx")
    alvo = st.selectbox("Selecione a doença a ser prevista:", ['DIABETES', 'HEART_ATTACK', 'STROKE'])
    modelo = st.selectbox("Selecione o modelo de predição:", ['Logistic Regression', 'Decision Tree', 'Random Forest', 'SVM', 'XGBoost'])
    
    X, y = preprocess_data(df, alvo)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    train_and_evaluate_model(modelo, X_train, X_test, y_train, y_test)

run()

